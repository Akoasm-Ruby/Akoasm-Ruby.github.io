<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akoasm 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-13T05:29:20.662Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Akoasm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20180613Test</title>
    <link href="http://yoursite.com/2018/06/13/20180613Test/"/>
    <id>http://yoursite.com/2018/06/13/20180613Test/</id>
    <published>2018-06-13T05:01:59.000Z</published>
    <updated>2018-06-13T05:29:20.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="T1-不能分治"><a href="#T1-不能分治" class="headerlink" title="T1 不能分治"></a>T1 不能分治</h1><p>时限:6s 空间:3MB</p><p>考虑到我们无法把数组存到内存中，所以直接找一种方法反复迭代它。</p><p>语句中明确提到向前迭代，如何向后就成为了处理的问题。</p><p>向后迭代只需要一些简单的恢复操作：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$a_i = (a_{i+1} - B) * A^{-1} \% C$</p><p>明确一个式子:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$a_{max_{l,r}} = max(a_l,a_{l+1} … a_r)$。</p><p>我们定义一个函数$f(l,r)$表示从$l$到$r$之间连续子序列的答案。</p><p>所以，考虑分治：</p><p>定义$g(l,r)$它是$l到r$之间每个区间$(a,b)$最大值之和,$l &lt;= a,b &lt;= r$。</p><p>计算$f(l,r)$就可以:</p><p>&nbsp;$f(l,r) = f(l,mid) + f(mid+1,r) + g(l,r) $</p><p>思路：</p><p>对于分离： 把序列不断分成两半。</p><p>对于治之：假设最大值位于序列的右半部，另一种情况被类似地对待。假设我们将右边的元</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;素$r$固定为我们所计算的子序列的上限。</p><p>我们将上面提到的$(a,b)$限制为：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$r &lt;= b$&nbsp;&nbsp;&nbsp;&nbsp; $ amax_{a,b} &lt;= a_r$ &nbsp;&nbsp;&nbsp;&nbsp;$amax_{mid+1,r-1} &lt; a_r$ &nbsp;&nbsp;&nbsp;&nbsp;$amax_{r,b} &lt;= a_r$</p><p>就完成了在线性时间内完成此题。</p><p>时间复杂度:$O(nlogn)$</p><h1 id="T2-不能走路"><a href="#T2-不能走路" class="headerlink" title="T2 不能走路"></a>T2 不能走路</h1><p>时限：1s  空间：512MB</p><p>正解：</p><p>随机选一个点为根。</p><p>容易得到一个结论：我们对于所有询问[X,Y]，我们破坏的一定是这些东西的LCA。</p><p>可以这么证明：</p><p>假设我们有一个解决方案，我们销毁一个点，使得这个点不代表任何节点对的LCA。我们用</p><p>S来表示经过的点路径。容易知道所有的路径S也必须通过X的父亲。</p><p>所以不是选择摧毁X我们可以摧毁X父亲。我们将相同类型的推理应用于X父亲等。</p><p>把LCA按照深度排序，深度最深的LCA先破坏，因为这是必要的，之后破坏不可能再满足这条</p><p>链的情况。破坏一个点之后删去和它影响的点</p><p>这样的复杂度是较大的。</p><p>考虑每次遍历子树（显然如果有关，至少有一个点在它的子树内）每个点如果被遍历两次是</p><p>没有意义的，我们用一个vis来保存一个点是否遍历过，如果已经遍历过就不用再遍历。</p><p>搞定！</p><h1 id="T3-最长上升子序列"><a href="#T3-最长上升子序列" class="headerlink" title="T3 最长上升子序列"></a>T3 最长上升子序列</h1><p>时限:3s  空间:512MB</p><p>先离散化一波。</p><p>首先10分做法可以直接暴力DP</p><p>记$f[i]$表示前i个数的LIS，那么寻找之前所有满足$a[i] &gt; a[j]$</p><p>的j，另$f[i]=max(f[j]+1,1)$。</p><p>对于20分，注意到这是一个经典问题，为了之后的几档分数，我们这里选择可以用树状数</p><p>组来进行优化。即求前缀中比它小的数的和。</p><p>每次处理一个数，就插入一个数。</p><p>这样，每次我们暴力修改，暴力求LIS能有50分</p><p>考虑如果我修改了一个数字，那么这时候答案是两部分的最大值：</p><p>1、经过这个点的LIS。</p><p>2、不经过这个点的LIS。</p><p>我们先考虑做1。</p><p>对于经过每个点的，就是前缀比他小的和后缀比它大的加起来，再加上它。</p><p>我们再分成三部分。</p><p>对于前缀比它小的，我们从左往右扫描，同时统计相应的答案（用树状数组维护）后缀同</p><p>理，再加一。当然也可以强行主席树做。</p><p>考虑2，不经过这点的LIS。</p><p>显然答案要么是原来的len，要么是$len-1$</p><p>这样我们只需要判断是否每一个LIS都必须经过它。</p><p>首先需要判断这个点是否能成为LIS的一部分。</p><p>设这个点的位置是i，要满足这个条件必须满足以i结束的最长上升子序列的长度加上以i</p><p>开始的最长上升子序列的长度是原来的LIS-1。</p><p>同时，你要保证它是唯一的。</p><p>比如对于1 2 2 3，中间的两个2就不是唯一的<br>。<br>怎么判断是否是唯一的？就是只有它能够转移到最后面，也就是如果存在$（i,j）$满足都</p><p>可能成为LIS的一部分的，如果以i结束的LIS的长度和以j结束的LIS长度相同，那么i和j就</p><p>可以互相替换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;T1-不能分治&quot;&gt;&lt;a href=&quot;#T1-不能分治&quot; class=&quot;headerlink&quot; title=&quot;T1 不能分治&quot;&gt;&lt;/a&gt;T1 不能分治&lt;/h1&gt;&lt;p&gt;时限:6s 空间:3MB&lt;/p&gt;
&lt;p&gt;考虑到我们无法把数组存到内存中，所以直接找一种方法反复迭代它
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="考试题解" scheme="http://yoursite.com/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>多项式</title>
    <link href="http://yoursite.com/2018/06/11/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/11/多项式/</id>
    <published>2018-06-11T03:24:10.000Z</published>
    <updated>2018-06-11T04:50:45.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>设$f(x)$为一个多项式，那么：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(x) =  \sum_{i = 0}^{n}a_ix^{i} $</p><h2 id="表现形式："><a href="#表现形式：" class="headerlink" title="表现形式："></a>表现形式：</h2><p>第一种是$f(x) = a(0) + a(1)x + a(2)x^{2} + … +a(n)x^{n} $</p><p>第二种是$f(x) = b(0) + b(1)C_{x}^{1} + … + b(n)C_{x}^{n} $</p><p>第三种是$ (x_0,f(x_0)) … (x_n,f(x_n)) $</p><p>其中第一种是多项式表示，第二种是二项式表示，第三种是点值表示。</p><h2 id="多项式加法："><a href="#多项式加法：" class="headerlink" title="多项式加法："></a>多项式加法：</h2><p>像初中学过的那样次数相同项相加，系数求和，得到最终答案。<br>例：<br>设：$A(x) = \sum_{i=0}^{n}a_ix^i$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$B(x) = \sum_{i=0}^{n}B_ix^i$<br>则:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$C(x) = \sum_{i=0}^{n}C_ix^i$</p><h2 id="多项式乘法："><a href="#多项式乘法：" class="headerlink" title="多项式乘法："></a>多项式乘法：</h2><p>对于每一项分别乘上另一个多项式的每一项，未知数次幂相加，系数相乘，得到新多项式。</p><p>如何表示?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$C(x) = \sum_{i=0}^{2n}c_ix^i$</p><p>每一项系数为：$\sum_{k = 0}^{j}a_kb_{j-k}$</p><p>基础概念到此结束</p><hr><h2 id="我是拉格朗日插值："><a href="#我是拉格朗日插值：" class="headerlink" title="我是拉格朗日插值："></a>我是拉格朗日插值：</h2><p>定义：对于一个多项式，已知给定的$ k + 1 $个点的取值点$ (x_0,y_0),(x_1,y_1)…(x_k,y_k) $</p><p>设任意两个$ x_j $都不相同，应用拉格朗日插值公式可以得到的多项式是：</p><p>$ L(x) = \sum_{j=0}^{k} y_i\ell_i $</p><p>其中，每个$ \ell{j}(x) $为拉格朗日基本多项式，表达式为：</p><p>$ \ell_j(x) = \prod_{i = 0,i \neq j }^{k} \frac{x - x_i}{x_j - x_i} $</p><p>拉格朗日基本多项式$ \ell{j}(x) $的特点是在$ x_{j} $上取值为1，其它点$ x_{i},i\neq j $上取值为0.</p><hr><h2 id="定理介绍："><a href="#定理介绍：" class="headerlink" title="定理介绍："></a>定理介绍：</h2><ol><li>对于给定的$n$个点值，能确定唯一的一个多项式，最高次数为$n-1$</li><li>对于系数表达的多项式，我们可以快速处理。</li></ol><hr><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><p>单位复数根：<br>$n次单位复数根$是满足$w^n = 1$的复数$w$。<br>$n次单位复数根恰好有n个，对于0&lt;=k&lt;=n-1，这些根是e^{2πik/n}$<br>所以可得定义：$e^{iu} = cos(u) + isin(u)$<br>这些单位复数根均匀分布在复平面的圆周上。<br>（表示不会画平面）<br>$w_n = e^{2πi/n}$被叫做主单位复数根，所有其他$n$次单位复数根都是$w_n$的幂。</p><p>因为$w_{n}^{n} = w_n^0 = 1$，那么可得:$w_n^jw_n^k = w_n^{(j+k)\%n}$</p><hr><h2 id="继续定理介绍："><a href="#继续定理介绍：" class="headerlink" title="继续定理介绍："></a>继续定理介绍：</h2><ol><li>消去引理:对于任何整数$n,k,d$ $(n,k&gt;=0 , d &gt; 0)$，$w_{dn}^{dk} = w_n^k$</li><li>对于任意偶数$n(n&gt;0)$有$w_n^{n/2} = w_2 = -1$</li><li>折半定理:如果$n(n&gt;0)$是偶数，那么$n$个$n$次单位复数根的平方集合就是$n/2$个$n/2$次单位复数根的集合。</li><li>求和定理：对于任意整数$n(n&gt;=1)$和不能被$n$整除的非负整数$k$有$\sum_{i=0}^{n-1}(w_n^k)^j = 0$</li></ol><hr><h2 id="重点1：DFT"><a href="#重点1：DFT" class="headerlink" title="重点1：DFT"></a>重点1：DFT</h2><p>根据以上知识，我们显然可以计算最高次数为$n$的多项式。<br>$=&gt;$ $f(x) = \sum_{i=0}^{n-1}a_ix^i$</p><p>$=&gt;$ 对于每一个$x$的结果$y$可以得$y_j = f(w_n^j) = \sum_{j=0}^{n-1}a_jw_n^{ij}$</p><hr><h2 id="推荐例题：HDU1402"><a href="#推荐例题：HDU1402" class="headerlink" title="推荐例题：HDU1402"></a>推荐例题：HDU1402</h2>]]></content>
    
    <summary type="html">
    
      处世
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="FFT" scheme="http://yoursite.com/tags/FFT/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>二分图以及网络流</title>
    <link href="http://yoursite.com/2018/06/10/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/06/10/二分图/</id>
    <published>2018-06-10T10:29:40.000Z</published>
    <updated>2018-06-11T04:50:44.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>对于一张无向图，$N$个节点$(N\geq2)$，可以分成$A和B$两个集合，其交集为空集，且集合内部无边相连，那么就称这张图是一张二分图。</p><hr><h2 id="判定："><a href="#判定：" class="headerlink" title="判定："></a>判定：</h2><p>利用$bfs 或 dfs$进行染色，一条边的两个端点异色。<br>$dfs$版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void dfs(int x,int col)&#123;</span><br><span class="line">    vis[x] = col;</span><br><span class="line">    for(int i = head[x];i;i = nxt[i])&#123;</span><br><span class="line">        int y = to[i];</span><br><span class="line">        if(!vis[y])&#123;</span><br><span class="line">            dfs(y,3-col);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[y] != col)&#123;</span><br><span class="line">            //不是二分图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//main:</span><br><span class="line">for(int i = 1;i &lt;= E; ++i)&#123;</span><br><span class="line">    if(!vis[i])&#123;</span><br><span class="line">        dfs(i,1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="定理："><a href="#定理：" class="headerlink" title="定理："></a>定理：</h2><p>二分图中不存在奇环。</p><hr><h2 id="最大匹配："><a href="#最大匹配：" class="headerlink" title="最大匹配："></a>最大匹配：</h2><p>匹配是二分图边的集合，且集合中任意边没有公共点，包含边数最多的匹配。</p><p>匈牙利算法：<br>在图中不断找增广路，不断使匹配数加1，知道不存在为止。</p><p>什么是增广路？<br>由一个未匹配的顶点开始，经过若干个匹配顶点，最后到达对面集合的一个未匹配顶点的路径，即这条路径将两个不同集合的两个未匹配顶点通过一系列匹配顶点相连。</p><p>$dfs$求匈牙利最大匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline bool dfs(int x)&#123;</span><br><span class="line">    for(int i = head[x];i;i=nxt[i])&#123;</span><br><span class="line">        int y = to[i];</span><br><span class="line">        if(!vis[y])&#123;</span><br><span class="line">            vis[y] = 1;</span><br><span class="line">            if(!used[y] || dfs(used[y])&#123;</span><br><span class="line">                used[y] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分图带权匹配："><a href="#二分图带权匹配：" class="headerlink" title="二分图带权匹配："></a>二分图带权匹配：</h2><p>二分图如果是没有权值的，求最大匹配。则是用匈牙利算法求最大匹配。如果带了权值，求最大或者最小权匹配，则必须用KM算法。</p><p>其实最大和最小权匹配都是一样的问题。只要会求最大匹配，如果要求最小权匹配，则将权值取相反数，再把结果取相反数，那么最小权匹配就求出来了。</p><p>相等子图：<br>二分图所有节点和满足$A_i + B_j = w(i,j) $的边构成的子图，称为二分图的相等子图。</p><p>定理：<br>若相等子图中存在完美匹配，则这个完美匹配就是二分图最大匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">const int maxn = ...;</span><br><span class="line">int w[maxn][maxn];</span><br><span class="line">int lx[maxn];</span><br><span class="line">int ly[maxn];</span><br><span class="line">bool visx[maxn];</span><br><span class="line">bool visy[maxn];</span><br><span class="line">int match[maxn];</span><br><span class="line">int n;</span><br><span class="line">int dat;</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    visx[x] = 1;//表示x点在交错树中</span><br><span class="line">    for(int i = 1;i &lt;= n; ++i)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            if(lx[x] + ly[i] - w[x][i] == 0)&#123; // 相等子图</span><br><span class="line">                visy[i] = 1;</span><br><span class="line">                if(!match[i] || dfs(match[i]))&#123;</span><br><span class="line">                    match[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            dat = min(dat,lx[x] + ly[i] - w[x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int KM()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt;= n; ++i)&#123;</span><br><span class="line">        lx[i] = -INF;</span><br><span class="line">        ly[i] = 0;</span><br><span class="line">        for(int j = 1;j &lt;= n; ++j)&#123;</span><br><span class="line">            lx[i] = max(lx[i],w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n; ++i)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            memset(visx,0,sizeof(visx));</span><br><span class="line">            memset(visy,0,sizeof(visy));</span><br><span class="line">            dat = INF;</span><br><span class="line">            if(dfs(i)) break;</span><br><span class="line">            for(int j = 1;j &lt;= n; ++j)&#123;</span><br><span class="line">                if(visx[j]) lx[j] -= dat;</span><br><span class="line">                if(visy[j]) ly[j] += dat;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n; ++i)&#123;</span><br><span class="line">        ans += w[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="最小点集覆盖"><a href="#最小点集覆盖" class="headerlink" title="最小点集覆盖"></a>最小点集覆盖</h2><p>在二分图中找一个尽量小的点集，使得图中每一条边至少有一个点在该点集中。<br>最小点集覆盖 $=$ 最大匹配</p><p>Konig定理：<br>二分图最小点集覆盖包含的点数等于二分图最大匹配包含的边数。</p><hr><h2 id="最小路径覆盖："><a href="#最小路径覆盖：" class="headerlink" title="最小路径覆盖："></a>最小路径覆盖：</h2><p>在二分图中寻找一个尽量小的边集，使图中每一个点都是该边集中某条边的端点。</p><p>最小路径覆盖 == 顶点数 - 最大匹配。</p><p>定理：<br>有向无环图G中最小路径覆盖包含的路径条数等于$N(N为二分图左部节点)$减去拆点二分图$G_2$的最大匹配数。</p><hr><h2 id="最大独立集："><a href="#最大独立集：" class="headerlink" title="最大独立集："></a>最大独立集：</h2><p>在N个点中选出来一个最大点集，使这个点集中的任意两点之间都没有边。</p><p>最大独立集 == 顶点数 - 最大匹配。</p><p>定理：<br>1.无向图的最大团等于其补图的最大独立集。<br>2.$G是N$个节点的的二分图，则$G的最大独立集的大小等于N减去最大匹配数。$</p><hr>]]></content>
    
    <summary type="html">
    
      处世
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="二分图" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>九省联考秘密袭击</title>
    <link href="http://yoursite.com/2018/06/10/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BB/"/>
    <id>http://yoursite.com/2018/06/10/九省联考秘密袭击/</id>
    <published>2018-06-10T05:51:48.000Z</published>
    <updated>2018-06-11T04:50:57.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意-给定一棵-N-个节点的树，求树的每一个联通块的第-K-大点权之和。"><a href="#题意-给定一棵-N-个节点的树，求树的每一个联通块的第-K-大点权之和。" class="headerlink" title="题意:给定一棵$N$个节点的树，求树的每一个联通块的第$K$大点权之和。"></a>题意:给定一棵$N$个节点的树，求树的每一个联通块的第$K$大点权之和。</h2><h2 id="前置技能-树上DP，多项式（FFT），拉格朗日插值法（高斯消元），线段树启发合并。"><a href="#前置技能-树上DP，多项式（FFT），拉格朗日插值法（高斯消元），线段树启发合并。" class="headerlink" title="前置技能:树上DP，多项式（FFT），拉格朗日插值法（高斯消元），线段树启发合并。"></a>前置技能:树上DP，多项式（FFT），拉格朗日插值法（高斯消元），线段树启发合并。</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>看题，事实上正解十分的。。有毒，所以直接考虑如何暴力搞掉它。</p><p>我们考虑枚举每个点，算出以这个店为第$K$大的联通块的个数。</p><p>也就是说对于每个点跑一遍树形DP，因为有重复，所以钦定只能从编号小的走到大的。</p><p>直接$dfs$加玄学剪枝即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 4010</span><br><span class="line">#define mod 64123</span><br><span class="line">int n,k,w,cnt,S,ans,head[N],d[N],f[N][N];</span><br><span class="line">struct node&#123;</span><br><span class="line">int to,next;</span><br><span class="line">&#125;edge[N];</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">int ans=0,f=1;</span><br><span class="line">char ch=getchar();</span><br><span class="line">while(ch&gt;&apos;9&apos;||ch&lt;&apos;0&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(ch==&apos;-&apos;)</span><br><span class="line">f=-1;</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line">while(ch&lt;=&apos;9&apos;&amp;&amp;ch&gt;=&apos;0&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+ch-&apos;0&apos;;</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line">return ans*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void add(int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">edge[++cnt].to=v;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">inline void up(int &amp;x,int y)</span><br><span class="line">&#123;</span><br><span class="line">x+=y;</span><br><span class="line">if(x&gt;=mod)x-=mod;</span><br><span class="line">&#125;</span><br><span class="line">inline void dfs(int x,int father,int g[])</span><br><span class="line">&#123;</span><br><span class="line">if(d[x]&gt;d[S]||(d[x]==d[S]&amp;&amp;x&gt;S))</span><br><span class="line">for(int i=1;i&lt;=k;i++)</span><br><span class="line">f[x][i]=g[i-1];</span><br><span class="line">else</span><br><span class="line">for(int i=1;i&lt;=k;i++)</span><br><span class="line">f[x][i]=g[i];</span><br><span class="line">for(int i=head[x];i;i=edge[i].next)</span><br><span class="line">if(edge[i].to!=father)dfs(edge[i].to,x,f[x]);</span><br><span class="line">for(int i=1;i&lt;=k;i++)</span><br><span class="line">up(g[i],f[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">inline void calc(int fx)</span><br><span class="line">&#123;</span><br><span class="line">int tot=1;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">if(d[i]&gt;d[fx]||(d[i]==d[fx]&amp;&amp;i&gt;fx))tot++;</span><br><span class="line">if(tot&lt;k)return ;</span><br><span class="line">S=fx;</span><br><span class="line">memset(f[fx],0,sizeof(f[fx]));</span><br><span class="line">f[fx][1]=1;</span><br><span class="line">for(int i=head[fx];i;i=edge[i].next)</span><br><span class="line">dfs(edge[i].to,fx,f[fx]);</span><br><span class="line">ans=(ans+1ll*d[fx]*f[fx][k])%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">n=read();k=read();w=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">d[i]=read();</span><br><span class="line">int u,v;</span><br><span class="line">for(int i=2;i&lt;=n;i++)</span><br><span class="line">u=read(),v=read(),add(u,v),add(v,u);</span><br><span class="line">for(int i=1;i&lt;=n;i++)calc(i);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      HEOI 2018 D1T3 难度:NOI+/CTSC
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树DP" scheme="http://yoursite.com/tags/%E6%A0%91DP/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="FFT" scheme="http://yoursite.com/tags/FFT/"/>
    
      <category term="拉格朗日插值" scheme="http://yoursite.com/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
      <category term="高斯消元" scheme="http://yoursite.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>APIO2018-新家</title>
    <link href="http://yoursite.com/2018/06/09/APIO2018-%E6%96%B0%E5%AE%B6/"/>
    <id>http://yoursite.com/2018/06/09/APIO2018-新家/</id>
    <published>2018-06-09T12:05:12.000Z</published>
    <updated>2018-06-11T04:50:15.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意：https-www-luogu-org-problemnew-show-P4632-sub"><a href="#题意：https-www-luogu-org-problemnew-show-P4632-sub" class="headerlink" title="题意：https://www.luogu.org/problemnew/show/P4632#sub"></a>题意：<a href="https://www.luogu.org/problemnew/show/P4632#sub" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4632#sub</a></h2><h2 id="前置技能：可持久化线段树，离散化，二分。"><a href="#前置技能：可持久化线段树，离散化，二分。" class="headerlink" title="前置技能：可持久化线段树，离散化，二分。"></a>前置技能：可持久化线段树，离散化，二分。</h2><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>第一眼看到题目感觉线性数据的线段树，但是如何实现？</p><p>注意到以$x$轴为时间轴建造一棵线段树。</p><p>显然可以认为有两种状态：商店的出现与消失。</p><p>离散化：没啥好说的，一般都离散。</p><p>将两种状态按照时间一次性处理，果断二分？？</p><p>那么问题就转化成了在$[x-mid,x+mid]$中是否含有所有种类的商店。</p><p>回答询问只需要记录前驱即可。</p><p>那么问题又转化成了：动态记录前驱以及后缀最小。</p><p>那么第一个问题只需要$set$维护第二个裸上线段树。</p><p>这样时间复杂度$O(log^{2}n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef priority_queue&lt;int ,vector&lt;int&gt; ,greater&lt;int&gt; &gt; heap;</span><br><span class="line">typedef set&lt;int&gt;::iterator iter;</span><br><span class="line">const int N=300005,M=1000005,inf=0x3f3f3f3f,rnf=1000000000;</span><br><span class="line">int read()&#123;</span><br><span class="line">int f=1,g=0;</span><br><span class="line">char ch=getchar();</span><br><span class="line">for (;!isdigit(ch);ch=getchar()) if (ch==&apos;-&apos;) f=-1;</span><br><span class="line">for (;isdigit(ch);ch=getchar()) g=g*10+ch-&apos;0&apos;;</span><br><span class="line">return f*g;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,q,cnt,ans[N];</span><br><span class="line">struct shop&#123;int x,t,a,b;&#125; a[M];</span><br><span class="line">struct event&#123;int typ,t,x,pos;&#125; b[M];</span><br><span class="line">set&lt;int&gt; h[N];</span><br><span class="line">struct segment_tree&#123;</span><br><span class="line">int key[M*3];</span><br><span class="line">void build(int x,int l,int r)&#123;</span><br><span class="line">if (l==r) &#123;key[x]=(l&lt;=n) ? inf : 0;return;&#125;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">build(x*2,l,mid);</span><br><span class="line">build(x*2+1,mid+1,r);</span><br><span class="line">key[x]=min(key[x*2],key[x*2+1]);</span><br><span class="line">&#125;</span><br><span class="line">int query(int x,int l,int r,int k)&#123;</span><br><span class="line">if (a[l].x&gt;k) return key[x];</span><br><span class="line">int mid=(l+r)&gt;&gt;1,t=inf;</span><br><span class="line">if (a[mid].x&gt;k) t=min(t,query(x*2,l,mid,k));</span><br><span class="line">t=min(t,query(x*2+1,mid+1,r,k));</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">void modify(int x,int l,int r,int p,int k)&#123;</span><br><span class="line">if (l==r) &#123;key[x]=k;return;&#125;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">if (p&lt;=mid) modify(x*2,l,mid,p,k);</span><br><span class="line">else modify(x*2+1,mid+1,r,p,k);</span><br><span class="line">key[x]=min(key[x*2],key[x*2+1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;f;</span><br><span class="line">bool cmp1(shop x,shop y)&#123;return x.x&lt;y.x;&#125;</span><br><span class="line">bool cmp2(event x,event y)&#123;return (x.t!=y.t) ? x.t&lt;y.t : x.typ&lt;y.typ;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read();m=read();q=read();</span><br><span class="line">for (int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;a[i].x=read();a[i].t=read();a[i].a=read();a[i].b=read();&#125;</span><br><span class="line">sort(a+1,a+n+1,cmp1);</span><br><span class="line">for (int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">b[++cnt]=(event)&#123;1,a[i].a,i&#125;;</span><br><span class="line">b[++cnt]=(event)&#123;3,a[i].b,i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">for (int i=1;i&lt;=q;i++)&#123;b[++cnt].typ=2;b[cnt].pos=i;b[cnt].x=read();b[cnt].t=read();&#125;</span><br><span class="line">sort(b+1,b+cnt+1,cmp2);</span><br><span class="line">for (int i=1;i&lt;=m;i++)&#123;h[i].insert(0);h[i].insert(i+n);a[i+n].x=inf;&#125;</span><br><span class="line">f.build(1,1,n+m);</span><br><span class="line">for (int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">if (b[i].typ==1)&#123;</span><br><span class="line">int x=b[i].x;h[a[x].t].insert(x);</span><br><span class="line">iter l=h[a[x].t].lower_bound(x),r=h[a[x].t].upper_bound(x);</span><br><span class="line">l--;</span><br><span class="line">f.modify(1,1,n+m,x,*l);</span><br><span class="line">f.modify(1,1,n+m,*r,x);</span><br><span class="line">&#125;</span><br><span class="line">else if (b[i].typ==2)&#123;</span><br><span class="line">int x=b[i].x,l=0,r=rnf,mid;</span><br><span class="line">while (l&lt;r)&#123;</span><br><span class="line">mid=(l+r)&gt;&gt;1;</span><br><span class="line">int fl=max(1,x-mid),fr=min(rnf-1,x+mid);</span><br><span class="line">if (a[f.query(1,1,n+m,fr)].x&gt;=fl) r=mid;</span><br><span class="line">else l=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">ans[b[i].pos]= (r!=rnf) ? r : -1;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int x=b[i].x;</span><br><span class="line">h[a[x].t].erase(x);</span><br><span class="line">iter l=h[a[x].t].lower_bound(x),r=h[a[x].t].upper_bound(x);</span><br><span class="line">l--;</span><br><span class="line">f.modify(1,1,n+m,x,inf);</span><br><span class="line">f.modify(1,1,n+m,*r,*l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      APIO 2018 T1 难度:NOI+/CTSC
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="可持久化" scheme="http://yoursite.com/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="离散化" scheme="http://yoursite.com/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CTSC2018P3</title>
    <link href="http://yoursite.com/2018/06/05/CTSC2018P3/"/>
    <id>http://yoursite.com/2018/06/05/CTSC2018P3/</id>
    <published>2018-06-05T14:11:37.000Z</published>
    <updated>2018-06-09T12:19:41.868Z</updated>
    
    <content type="html"><![CDATA[<p>对于答案式子$f(n)=(n−1)f(n−1)+\sum_{i=2}^{n-2}(i−1)f(i)f(n−i)$，后面的部分不是很好处理，下面对这个式子的求解详细分析：</p><p>1.首先由于分治NTT的顺序类似二叉树的中序遍历，所以当我们算到底层的$f(n)时，f(1),f(2),…,f(n−1)$都应该算完了，所以前面的$(n−1)f(n−1)$在底层加上去就好了。</p><p>2.后面的部分由于做卷积的都是“自身”，所以似乎不那么好处理。</p><p>为了求解后面的式子，不妨采用一种“试探+调整”的思路。按照分治NTT的套路，应该把[l,mid]这一段与自身（可能其中一个要乘上一个系数）做卷积，$再讨论对[mid+1,r]区间的贡献。这样就能得到对f([max(2l,mid+1),r])的一些$<br>$贡献，注意这里mid+1和2l大小关系未知。$</p><p>由于这样的分治要求在讨论$[mid+1,r]$之前要把之前区间所有的贡献都加上去，那么我们考虑还有哪些答案没有被加上去。</p><p>“之前的区间”是指哪些区间呢？显然是整个$[2,mid]$区间。由分治的顺序可知我们之前已经把$[2,l−1]$里$f$的卷积贡献加到了$[mid+1,r]$上，也把$[l,mid]$里$f$的卷积的贡献加到了$[mid+1,r]上，那么当然只剩下了[2,l−1]和[l,mid]$里各取一个f的贡献没有被计算到了。注意到这里必然有一个配对的形式：$f(a)和f(b)$的总贡献是$(a−1)f(a)f(b)和(b−1)f(b)f(a)，$两项加起来是$(a+b−2)f(a)f(b)$。所以我们只需要把两段区间的f先做卷积，在算贡献的时候把前面的系数乘上去即可。</p><p>这里做的正确性十分显然：首先显然不会算漏，同时也不会算重：讨$论[2,l−1]时，[l,mid+1]一定没有算$出来，不会加到答案里面。</p><p>同时注意到这里补充贡献的操作中，用来$与f([l,mid])做$卷积的多项式次数$为min(l−1,r−l)。因为不会超过r−l，$所以复杂度是有保证的。总时间复杂$度O(nlog^2n+Tn)$。Tn是每组询问用一个栈维护区间包含关系，比较简单就不详细说了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1 &lt;&lt; 20;</span><br><span class="line">const int mo = 998244353;</span><br><span class="line"></span><br><span class="line">int read() &#123;</span><br><span class="line">    int n = 0, f = 1;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    for(;!isdigit(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1;</span><br><span class="line">    for(; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48;</span><br><span class="line">    return n * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fpm(int x, int y) &#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    for(; y &gt; 0; y &gt;&gt;= 1) &#123;</span><br><span class="line">        if(y &amp; 1)</span><br><span class="line">            res = (ll) res * x % mo;</span><br><span class="line">        x = (ll) x * x % mo;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Poly &#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    void init(int m) &#123;</span><br><span class="line">        n = m;</span><br><span class="line">        while(n &gt; (n &amp; -n)) n += (n &amp; -n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dft(int *x, int ty) &#123;</span><br><span class="line">        for(int i = 0, j = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if(i &lt; j) std::swap(x[i], x[j]);</span><br><span class="line">            for(int l = n &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int l = 1; l &lt; n; l &lt;&lt;= 1) &#123;</span><br><span class="line">            int wn = fpm(3, (mo - 1) / l / 2);</span><br><span class="line">            if(ty == -1) wn = fpm(wn, mo - 2);</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; n; i += (l &lt;&lt; 1)) &#123;</span><br><span class="line">                int w = 1;</span><br><span class="line"></span><br><span class="line">                for(int j = 0; j &lt; l; ++j) &#123;</span><br><span class="line">                    int u = x[i + j];</span><br><span class="line">                    int v = (ll) x[i + j + l] * w % mo;</span><br><span class="line"></span><br><span class="line">                    w = (ll) w * wn % mo;</span><br><span class="line">                    x[i + j] = (u + v) % mo;</span><br><span class="line">                    x[i + j + l] = (u - v + mo) % mo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(ty == -1) &#123;</span><br><span class="line">            int invn = fpm(n, mo - 2);</span><br><span class="line">            for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                x[i] = (ll) x[i] * invn % mo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int T, n;</span><br><span class="line">int x[N + 5], f[N + 5];</span><br><span class="line">int a[N + 5], b[N + 5];</span><br><span class="line"></span><br><span class="line">void calc(int l, int r) &#123;</span><br><span class="line">    if(l == r) &#123;</span><br><span class="line">        f[l] = (f[l] + (ll) f[l-1] * (l-1)) % mo;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m = (l + r) &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    calc(l, m);</span><br><span class="line"></span><br><span class="line">    Poly::init(r - l + 1);</span><br><span class="line">    for(int i = 0; i &lt; Poly::n; ++i) a[i] = (i + l &lt;= m ? f[i + l] : 0);</span><br><span class="line">    for(int i = 0; i &lt; Poly::n; ++i) b[i] = (i + l &lt;= m ? (ll) f[i + l] * (i + l - 1) % mo : 0);</span><br><span class="line"></span><br><span class="line">    Poly::dft(a, +1); Poly::dft(b, +1);</span><br><span class="line">    for(int i = 0; i &lt; Poly::n; ++i) a[i] = (ll) a[i] * b[i] % mo;</span><br><span class="line">    Poly::dft(a, -1);</span><br><span class="line">    for(int i = m + 1; i &lt;= r; ++i) if(i &gt;= 2 * l) f[i] = (f[i] + a[i - 2 * l]) % mo;</span><br><span class="line"></span><br><span class="line">    if(l != 2) &#123;</span><br><span class="line">        for(int i = 0; i &lt; Poly::n; ++i) a[i] = ((i + 2 &lt;= r-l &amp;&amp; i + 2 &lt; l) ? f[i + 2] : 0);</span><br><span class="line">        for(int i = 0; i &lt; Poly::n; ++i) b[i] = (i + l &lt;= m ? (ll) f[i + l] : 0);</span><br><span class="line"></span><br><span class="line">        Poly::dft(a, +1); Poly::dft(b, +1);</span><br><span class="line">        for(int i = 0; i &lt; Poly::n; ++i) a[i] = (ll) a[i] * b[i] % mo;</span><br><span class="line">        Poly::dft(a, -1);</span><br><span class="line">        for(int i = m + 1; i &lt;= r; ++i) if(i &gt;= 2 + l) f[i] = (f[i] + (ll) a[i - 2 - l] * (i - 2)) % mo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calc(m + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    f[0] = 1;</span><br><span class="line">    f[1] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve(int L, int R) &#123;</span><br><span class="line">    if(L == R) return 1;</span><br><span class="line">    if(R - x[R] != L - 1) return 0;</span><br><span class="line"></span><br><span class="line">    int ans = 1;</span><br><span class="line">    int p = R - 1, cnt = 0;</span><br><span class="line">    for(; p - x[p] + 1 &gt;= L &amp;&amp; p &gt;= L; p = p - x[p]) &#123;</span><br><span class="line">        ++ cnt;</span><br><span class="line">        ans = (ll) ans * solve(p - x[p] + 1, p) % mo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(p != L - 1) return 0;</span><br><span class="line">    return (ll) ans * (f[cnt]+mo) % mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    for(T = read(), n = read(), calc(2, n); T--; ) &#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; ++i) x[i] = read();</span><br><span class="line">        printf(&quot;%d\n&quot;, solve(1, n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      CTSC 2018 D1T3 难度:NOI+/CTSC
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CTSC2018P2</title>
    <link href="http://yoursite.com/2018/06/05/CTSC-2018-P2/"/>
    <id>http://yoursite.com/2018/06/05/CTSC-2018-P2/</id>
    <published>2018-06-05T09:42:12.000Z</published>
    <updated>2018-06-11T04:47:42.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暴力写挂"><a href="#暴力写挂" class="headerlink" title="暴力写挂"></a>暴力写挂</h2><h2 id="题意：给定两棵带边权的树-T-和-T’-求点对-x-y-使得：-dep-x-dep-y-dep-lca-x-y-dep’-lca’-x-y"><a href="#题意：给定两棵带边权的树-T-和-T’-求点对-x-y-使得：-dep-x-dep-y-dep-lca-x-y-dep’-lca’-x-y" class="headerlink" title=" 题意：给定两棵带边权的树$T 和 T’$,求点对$(x,y)$使得：$dep(x) + dep(y) - dep(lca(x,y)) - dep’(lca’(x,y)) $"></a> 题意：给定两棵带边权的树$T 和 T’$,求点对$(x,y)$使得：$dep(x) + dep(y) - dep(lca(x,y)) - dep’(lca’(x,y)) $</h2><h2 id="数据范围：-n-lt-366666-4s"><a href="#数据范围：-n-lt-366666-4s" class="headerlink" title=" 数据范围： $ n &lt;= 366666 , 4s$"></a> 数据范围： $ n &lt;= 366666 , 4s$</h2><h2 id="前置技能：点分治，边分治，虚树，点分树（动态点分治），线段树，边分树。"><a href="#前置技能：点分治，边分治，虚树，点分树（动态点分治），线段树，边分树。" class="headerlink" title=" 前置技能：点分治，边分治，虚树，点分树（动态点分治），线段树，边分树。"></a> 前置技能：点分治，边分治，虚树，点分树（动态点分治），线段树，边分树。</h2><h2 id="流程："><a href="#流程：" class="headerlink" title=" 流程："></a> 流程：</h2><p>对于$T’$，我们首先枚举一个点对$(x,y)$在它上的LCA，然后问题就成功转化成了:在第一棵树中加入若干个$x$，询问时对于某个$y$，$min(dep(x) + dep(y) - dep(lca(x,y))$的值。</p><p>可以发现本质是树上路径，上点分治，考虑重心连出去的若干个子树中一定有一个是恰好靠近根节点的。</p><p>如果点对$(x,y)$不在那棵子树中，那么$lca(x,y)$就是重心。</p><p>否则的话，设$x$在靠近根节点的子树中，$y$不在，那么$lca(x,y) &lt;=&gt; lca(x,G)$ $(G为重心）$，可以发现只与$x$有关，可以直接预处理并且将信息添加到每个$x$上面。</p><p>所以只要维护不靠近根节点最大值，次大值，以及靠近根节点的最大值，这道题就可做了。</p><p>对于枚举$T’$上的$LCA$，一般可以用启发合并来做，但是启发合并自带一只$log$的复杂度，对于此题统计链的信息，如用点分治，复杂度与点相关，直接GG。</p><p>而且需要支持动态加入。</p><p>对于点分树，在其上难以删除，使用树上启发维护，极致写法也只是$O(nlog^{2}n)$</p><p>所以直接考虑边分治，对于这棵边分树，发现到它的二叉性质，形如线段树，直接边分树上跑线段树合并即可。</p><p>总复杂度$O(nlogn)。$</p><p>  $Code:$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机序列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 366667</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">char</span> ch;<span class="keyword">bool</span> fs;<span class="function"><span class="keyword">void</span> <span class="title">re</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),ch&lt;<span class="number">33</span>);</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'-'</span>)fs=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">else</span> fs=<span class="number">0</span>,x=ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),ch&gt;<span class="number">33</span>)x=x*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">if</span>(fs)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL ans=<span class="number">-1l</span>l&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> n,now,s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL far[N];</span><br><span class="line">    <span class="keyword">int</span> dep[N],dfn[N],mn[<span class="number">20</span>][N+N],e[N+N];</span><br><span class="line">    <span class="keyword">int</span> cnt,head[N],nxt[N+N],to[N+N],w[N+N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nxt[++cnt]=head[u];head[u]=cnt;to[cnt]=v;w[cnt]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[u]=++cnt;mn[<span class="number">0</span>][cnt]=u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=nxt[i])</span><br><span class="line">            <span class="keyword">if</span>((v=to[i]) != fa)</span><br><span class="line">            &#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                far[v]=far[u]+w[i];</span><br><span class="line">                dfs(v,u);</span><br><span class="line">                mn[<span class="number">0</span>][++cnt]=u;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        u=dfn[u];v=dfn[v];</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)swap(u,v);</span><br><span class="line">        <span class="keyword">int</span> t=e[v-u+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dep[mn[t][u]]&lt;dep[mn[t][v-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>]]?mn[t][u]:mn[t][v-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,c;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            re(u),re(v),re(c);</span><br><span class="line">            add(u,v,c);</span><br><span class="line">            add(v,u,c);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k=<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>;j+k&lt;=cnt;++j)</span><br><span class="line">                mn[i][j]=dep[mn[i<span class="number">-1</span>][j]]&lt;dep[mn[i<span class="number">-1</span>][j+k]]?mn[i<span class="number">-1</span>][j]:mn[i<span class="number">-1</span>][j+k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;++i)</span><br><span class="line">            e[i]=e[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t[now].far[a]&lt;t[now].far[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryy</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL mx=<span class="number">0</span>,num=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            LL cur=t[<span class="number">0</span>].far[u]+t[<span class="number">0</span>].far[i]-t[<span class="number">0</span>].far[t[<span class="number">0</span>].lca(u,i)]-t[<span class="number">1</span>].far[t[<span class="number">1</span>].lca(u,i)];</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;mx)</span><br><span class="line">                mx=cur,num=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;last)last=mx,u=num;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=max(ans,mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sta=clock();</span><br><span class="line">    re(n);</span><br><span class="line">    t[<span class="number">0</span>].init();</span><br><span class="line">    t[<span class="number">1</span>].init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)s[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(now=<span class="number">0</span>;now&lt;=<span class="number">1</span>;++now)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(s+<span class="number">1</span>,s+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=min(n,<span class="number">30</span>)&amp;&amp;<span class="number">1.0</span>*(clock()-sta)/CLOCKS_PER_SEC&lt;<span class="number">3.9</span>;++i)</span><br><span class="line">            tryy(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    random_shuffle(s+<span class="number">1</span>,s+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n &amp;&amp; <span class="number">1.0</span>*(clock()-sta)/CLOCKS_PER_SEC&lt;<span class="number">3.9</span>;++i)</span><br><span class="line">        tryy(s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边分树，线段树，虚树。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;a,<span class="keyword">int</span>&amp;b)</span></span>&#123;<span class="keyword">int</span> t=a;a=b;b=t;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;a,<span class="keyword">const</span> <span class="keyword">int</span>&amp;b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">max</span><span class="params">(<span class="keyword">const</span> ll&amp;a,<span class="keyword">const</span> ll&amp;b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upa</span><span class="params">(ll&amp;a,<span class="keyword">const</span> ll&amp;b)</span></span>&#123;a&lt;b?a=b:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">char</span> ibuf[<span class="number">1</span>&lt;&lt;<span class="number">25</span>],*ih=ibuf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>&amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(*ih);++ih)<span class="keyword">if</span>(*ih==<span class="string">'-'</span>)f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;<span class="built_in">isdigit</span>(*ih);x=x*<span class="number">10</span>+*ih++<span class="number">-48</span>);x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">366675</span>;</span><br><span class="line"><span class="keyword">const</span> ll inF=<span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,v;</span><br><span class="line">&#125;e[N*<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ecnt=<span class="number">1</span>,h1[N],h2[N],h3[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v,<span class="keyword">int</span>*h)</span></span>&#123;</span><br><span class="line">e[++ecnt]=(edge)&#123;y,h[x],v&#125;;h[x]=ecnt;</span><br><span class="line">e[++ecnt]=(edge)&#123;x,h[y],v&#125;;h[y]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,x,y,v,i,j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll mxl,mxr;</span><br><span class="line">&#125;t[N*<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> xb,f[<span class="number">21</span>][N*<span class="number">2</span>],lo[N*<span class="number">2</span>],id[N];</span><br><span class="line">ll dep1[N],dep2[N];</span><br><span class="line"><span class="keyword">int</span> depe[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],X,bel[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)<span class="keyword">return</span> a[l];</span><br><span class="line"><span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>,ans=++cnt;bel[ans]=X;</span><br><span class="line">addedge(ans,build(l,m),<span class="number">1</span>,h3);addedge(ans,build(m+<span class="number">1</span>,r),<span class="number">1</span>,h3);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdep</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][id[x]=++xb]=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h1[x];i;i=e[i].next)<span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">dep1[e[i].to]=dep1[x]+e[i].v;</span><br><span class="line">getdep(e[i].to,x);f[<span class="number">0</span>][++xb]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> xb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h1[x];i;i=e[i].next)<span class="keyword">if</span>(e[i].to!=fa)a[++xb]=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(xb==<span class="number">1</span>)addedge(x,a[<span class="number">1</span>],<span class="number">1</span>,h3);</span><br><span class="line"><span class="keyword">if</span>(xb&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> m=(xb+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;X=x;</span><br><span class="line">addedge(x,build(<span class="number">1</span>,m),<span class="number">1</span>,h3);addedge(x,build(m+<span class="number">1</span>,xb),<span class="number">1</span>,h3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> depe[x]&lt;depe[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">x=id[x];y=id[y];<span class="keyword">if</span>(x&gt;y)swap(x,y);</span><br><span class="line"><span class="keyword">int</span> l=lo[y-x+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> cmp(f[l][x],f[l][y-(<span class="number">1</span>&lt;&lt;l)+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dep1[y]-dep1[lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root[N],rt,sum,sz[N*<span class="number">2</span>],g[N*<span class="number">2</span>],dad[N*<span class="number">2</span>],de[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getce</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[x]=<span class="number">1</span>;dad[x]=fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h3[x];i;i=e[i].next)<span class="keyword">if</span>(e[i].to!=fa &amp;&amp; e[i].v)</span><br><span class="line">de[e[i].to]=i,getce(e[i].to,x),sz[x]+=sz[e[i].to];</span><br><span class="line">g[x]=max(sz[x],sum-sz[x]);</span><br><span class="line"><span class="keyword">if</span>(g[x]&lt;g[rt])rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">100</span>],w,st2[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gett</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,*z=root+x;i&lt;=w;++i)&#123;</span><br><span class="line">*z=++cnt;</span><br><span class="line"><span class="keyword">if</span>(st2[i])t[*z].mxr=dep1[x],t[*z].mxl=-inF,z=&amp;t[*z].r;</span><br><span class="line"><span class="keyword">else</span> t[*z].mxl=calc(bel[st[i]],x),t[*z].mxr=-inF,z=&amp;t[*z].l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">e[de[x]].v=e[de[x]^<span class="number">1</span>].v=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y=dad[x];</span><br><span class="line">sz[y]=sum-sz[x];</span><br><span class="line"><span class="keyword">if</span>(depe[x]&lt;depe[y])swap(x,y);</span><br><span class="line">st[++w]=x;st2[w]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sz[x]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">sum=sz[x];rt=<span class="number">0</span>;getce(x,<span class="number">0</span>);</span><br><span class="line">solve(rt);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=n)gett(x);</span><br><span class="line">st2[w]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sz[y]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">sum=sz[y];rt=<span class="number">0</span>;getce(y,<span class="number">0</span>);</span><br><span class="line">solve(rt);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(y&lt;=n)gett(y);</span><br><span class="line">--w;</span><br><span class="line">&#125;</span><br><span class="line">ll ans,D;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)<span class="keyword">return</span> x|y;</span><br><span class="line">t[x].l=merge(t[x].l,t[y].l);</span><br><span class="line">t[x].r=merge(t[x].r,t[y].r);</span><br><span class="line">upa(ans,max(t[x].mxl+t[y].mxr,t[y].mxl+t[x].mxr)-D);</span><br><span class="line">upa(t[x].mxl,t[y].mxl);</span><br><span class="line">upa(t[x].mxr,t[y].mxr);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">upa(ans,dep1[x]-dep2[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h2[x];i;i=e[i].next)<span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">dep2[e[i].to]=dep2[x]+e[i].v;</span><br><span class="line">dfs(e[i].to,x);D=dep2[x];</span><br><span class="line">root[x]=merge(root[x],root[e[i].to]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdep2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h3[x];i;i=e[i].next)<span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">depe[e[i].to]=depe[x]+<span class="number">1</span>;getdep2(e[i].to,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fread(ibuf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">25</span>,<span class="built_in">stdin</span>);</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">read(x),read(y),read(v);</span><br><span class="line">addedge(x,y,v,h1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">read(x),read(y),read(v);</span><br><span class="line">addedge(x,y,v,h2);</span><br><span class="line">&#125;<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)bel[i]=i;</span><br><span class="line">cnt=n;</span><br><span class="line">getdep(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">getdep2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;xb;++i)lo[i+<span class="number">1</span>]=lo[i]+!(i&amp;(i<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=lo[xb];++i)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=xb-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>;++j)</span><br><span class="line">f[i][j]=cmp(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]);</span><br><span class="line">g[<span class="number">0</span>]=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">rt=<span class="number">0</span>;sum=cnt;getce(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">solve(rt);</span><br><span class="line">ans=-inF;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      CTSC 2018 D1T2 难度:NOI+/CTSC
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="点分树" scheme="http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
      <category term="点分治" scheme="http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="虚树" scheme="http://yoursite.com/tags/%E8%99%9A%E6%A0%91/"/>
    
      <category term="边分树" scheme="http://yoursite.com/tags/%E8%BE%B9%E5%88%86%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>绍兴一中集训报告</title>
    <link href="http://yoursite.com/2018/06/04/%E9%9B%86%E8%AE%AD%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2018/06/04/集训报告/</id>
    <published>2018-06-04T10:58:28.000Z</published>
    <updated>2018-06-05T05:57:24.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0:"></a>Day0:</h2><p>全天火车行动：<br>    惊奇发现艾沐带的行李居然比孟老师多？（/滑稽）<br>    全天充当了孟—专用行李器，火车睡了一天。。。</p><p>周日晚上赶到绍兴，找了个大酒店随手住下，和艾沐住一个房间，并get到1张50代金券。<br>吃饭点餐的时候被那里的物品价格所惊到。。。<br>结账：虽然点的少，可还是超了48块钱，大龙老师很爽快的垫上了（估计心中满满的吐槽QWQ）<br>晚上拉着孟老师看恐怖片，吓的她直接溜走了。。。<br>然后开始开车。。。</p><h2 id="Day1："><a href="#Day1：" class="headerlink" title="Day1："></a>Day1：</h2><p>今天天气还不错，而且也没什么事，早上去吃饭，感受到南方满满的恶意。。。<br>全**是甜品啊？？！！—-WTF<br>除了米饭，全是甜的，这让我十分怀念了一中虽然不好吃的食堂。。。（至少不是甜的）<br>之后开始报到，随手填了个表，然后直接安排宿舍。<br>宿舍很宽敞，好评，用了一下午搞定了自己的宿舍，和艾沐一起坐等另外一个舍友（颓废），等来了一个山东的小朋友。。。（初二？！！）<br>好吧实力挺强的，感觉还是太菜了。。。</p><h2 id="Day2："><a href="#Day2：" class="headerlink" title="Day2："></a>Day2：</h2><p>今天正式开始讲课了，理性的选择了NOI场去听课。<br>主讲叫rxd，NOI2017金牌，当时没多惊异，今天才发现他是IOI预备队第四。（orz）<br>讲的点分治：<br>    科普:<br>      点分治:一种数据结构,处理树上路径的一种高优算法。<br>      点分树：<br>    听IOI未来牌爷讲课，全程处于完全听不懂的状态，一共讲了7个题，详述过程：<br>        unsigned long long HP = INF,rp = INF.<br>        T1：HP—,rp—;<br>        T2:HP—,rp—;<br>        T3:HP—,rp—;<br>        T4:HP—,rp—;<br>        T5:HP—,rp—;<br>        T6:HP—,rp—;<br>        T7（CTSC2018）暴力写挂：HP -= INF&lt;&lt;1,rp = -INF。$<br>      然后开始做题：<br>        一共留了11个题，切了一天只切了6个，其中有一道题叫做Union on tree，点分树神题，by 陈立杰老师，正解300+，点分树上虚树。</p><p>回到宿舍，HP恢复为0，rp恢复，躺着颓废。。。<br>两个淋浴室，热水供应，好评！！</p><h2 id="Day3："><a href="#Day3：" class="headerlink" title="Day3："></a>Day3：</h2><p>考试日。<br>早上起来吃完饭直接去考场，开考还有40min，紧急又敲了点分治的板子，以及各种**的板子，然后就发现。。。我板子崩了？？？好吧，要凉~~</p><p>NOI模拟开场：<br>    T1：纯粹SB题，居然还有读入压缩？？<br>       emmm，想了一会儿觉得很简单，最终用RMQ写出来，发现错了？？？WTF<br>       然后n^2暴力，发现输出结果一样错了，和RMQ的一样。<br>       然后n^3暴力，同上？？<br>       难道我脸黑吗？？！！  1.5h写完，调了2.5小时没调对心态崩掉，直接拎包吃饭。</p><p>后来看NOIP的模拟，全是无聊的题：T1 树状数组裸题，T2T3瞎搞。。。</p><p>下午来了听讲课，发现T1和正解思路一模一样，后来出题人告诉我，题有问题，在某一步计算lastAns时会爆longlong，直接让它爆掉就好了。。<br>一改，发现A了，瞬间心里：(mmp<em>INF)+INF</em>INF飘过</p><p>附题解：<br>    T1：SB题，分块+区间RMQ+单调栈解决即可，莫队似乎会被卡。。。<br>    T2：皮克定理（初中知识）统计三角形个数，最后做前缀和。<br>    T3：m范围很小，考虑设计状压DP的状态，可以想到设到达某个坐标j（将m维坐标压成m位四进制数）步数为k（距离等价于步数）的点数，但是难以转移。考虑按维转移，考虑每一维往外走的情况来转移。<br>    设$f{i,j,k}$表示前i维，到达坐标j，步数为k的点数。转移时枚举第i+1维的坐标l，假设坐标j的第i+1维是x，那么：<br>    $f(i+1,j+(l-x)<em> 4^i,k+|x-l|)+=f(i,j,k)$<br>    最后统计答案的时候，对于每个点坐标$j$将$f[m][j][…]$累加进答案即可。<br>    复杂度 $O(m</em>4^{m}<em> 3m</em>3)$</p><p>下午看浙江选手讨论题，发现气氛特别好，特别认真，没有胡闹的，讲课听得也很认真，不懂得及时就问了，而且分数一个个贼tm高。。。好评~~</p><p>而且他们一周考两次试。。。</p><p>晚上回去回顾一天，后悔考NOI的，算了，开始颓废（继续开车）</p><h2 id="Day4："><a href="#Day4：" class="headerlink" title="Day4："></a>Day4：</h2><p>练习日：<br>    一天也没干啥，打了一天代码，和艾沐以及小朋友共同学习一波。。。<br>    然后就发现我对面的哥们打嗝打了一天，还赠送了一波屁声？？<br>    差评。</p><p>晚上宿舍在大厅见到大龙老师以及孟老师，心里咯噔一声，鸡汤is coming（手动滑稽）<br>果不其然，鸡汤一波波~~最后发现，五点回到大厅，六点回到宿舍 OwO</p><p>晚上：打题，以及颓废。</p><h2 id="Day5："><a href="#Day5：" class="headerlink" title="Day5："></a>Day5：</h2><p>讲课：多项式。<br>感谢某位老师给讲过FFT，感谢各种大佬的博客使我会了NTT，打了一个清华集训和一个NOI的题目（多项式/数学），之后就是各种学拉格朗日插值以及做题。<br>科普：拉格朗日插值：</p><ul><li>拉格朗日插值<br>定义：对于一个多项式，已知给定的$ k + 1 $个点的取值点$ (x_0,y_0),(x_1,y_1)…(x_k,y_k) $</li></ul><p>设任意两个$ x_j $都不相同，应用拉格朗日插值公式可以得到的多项式是：</p><p>$ L(x) = \sum_{j=0}^{k} y_i\ell_i $</p><p>其中，每个$ \ell{j}(x) $为拉格朗日基本多项式，表达式为：</p><p>$ \ell_j(x) = \prod_{i = 0,i \neq j }^{k} \frac{x - x_i}{x_j - x_i} $</p><p>拉格朗日基本多项式$ \ell{j}(x) $的特点是在$ x_{j} $上取值为1，其它点$ x_{i},i\neq j $上取值为0.</p><p>例子：<br>设现在有某个二次多项式$f$，已知它在三个点上的取值为：<br>$f(4) = 10$<br>$f(5) = 5.25$<br>$f(6) = 1$。<br>求$f(18)$的值。<br>首先写出拉格朗日基本式：<br>$ \ell_0(x) = \frac{(x - 5)(x - 6)}{(4 - 5)(4 - 6)} $<br>$ \ell_1(x) = \frac{(x - 4)(x - 6)}{(5 - 4)(5 - 6)} $<br>$ \ell_2(x) = \frac{(x - 4)(x - 5)}{(6 - 4)(6 - 5)} $</p><p>后应用拉格朗日插值得到$p$的表达式：（$p$为函数$f$的插值函数）<br>$ p(x) = f(4)\ell_0(x) + f(5)\ell_1(x) + f(6)\ell_2(x) $<br>最终得到$p(x) = \frac{1}{4} (x^{2} - 28x + 136) $，此时带入数字18即可。</p><ul><li>唯一性</li></ul><p>次数不超过$k$的拉格朗日多项式至多只有一个:<br>对任意两个次数不超过$k$的拉格朗日多项式：$P_1$和$P_2$，它们的差<br>$P_1 - P_2$在所有$k+1$个点上取值都是0,因此必然是多项式$(x - x_0)…(x - x_k) $的倍数。<br>因此，如果这个差$ P_1 - P_2 $不等于0，次数就一定不小于$k+1$。<br>但是$P_1 - P_2$是两个次数不超过$k$的多项式之差，它的次数也不超过$k$。<br>所以$P_1 - P_2 = 0 $，也就是$P_1=P_2$。<br>得证</p><ul><li>code实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;string&gt;  </span><br><span class="line">#include&lt;vector&gt;  </span><br><span class="line">using namespace std;</span><br><span class="line">double Lagrange(int n,vector&lt;double&gt;&amp;X,vector&lt;double&gt;&amp;Y,double x)&#123;  </span><br><span class="line">  double ret=0;  </span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;  </span><br><span class="line">        double tmp=Y[i];  </span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;  </span><br><span class="line">            if(i!=j) &#123;  </span><br><span class="line">                tmp*=(x-X[j]);  </span><br><span class="line">                tmp/=(X[i]-X[j]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ret+=tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">    int n;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    vector&lt;double&gt;X(n,1);  </span><br><span class="line">    vector&lt;double&gt;Y(n,1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;  </span><br><span class="line">        cin&gt;&gt;X[i]&gt;&gt;Y[i];  </span><br><span class="line">    &#125;</span><br><span class="line">    double x;  </span><br><span class="line">    std::cin&gt;&gt;x;  </span><br><span class="line">    std::cout&lt;&lt;Lagrange(n,X,Y,x)&lt;&lt;endl;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>晚上：各种颓废。。。</p><h2 id="Day6："><a href="#Day6：" class="headerlink" title="Day6："></a>Day6：</h2><p>考试日：<br>到的比较晚直接开场了。。。要凉。。</p><p>首先看T1，交互？？！！<br>下发了一个$grader$文件并不知道怎么用，考场上写了个函数直接套用进去了，发现调用次数果断崩掉。。。</p><p>8点半开始看T2，两种思路：$SAM$和$DP$，读了10min的题发现dp，比较水。。<br>大概两个数组:$f[i][j]$和$g[i][j]$表达处理到i前j个和后j个满足的。。<br>脑中自胡一遍就开始看T3。</p><p>T3：最简单的？？<br>    题目大意：给定一个长度为$n$的序列，从中选出k长度的序列使得你选出的序列最大值与次大值的和最大，输出和，带单点修改。<br>    首先考虑不带修改，莫队什么的随便做了，最终考虑了线段树。。<br>    带修改？想了一会儿想了一种$n*k$的做法，发现绝对爆掉而且不好实现，为了不能两天没有分，直接去考了NOIP模拟赛。</p><p>10点开始看NOIP模拟赛T3：<br>      带修改LIS，一眼秒了，两种思路：树状数组或者可持久化线段树，考场上推了一手时间复杂度，发现线段树时间大概是树状数组4倍，然后直接码上树状数组，对拍100组数据点搞定~~  用时40min。</p><p>大概10点50开始看T1：<br>      同样一眼秒了，题目大概是给出序列问其中的一段序列中是否全是x？<br>      想了一下ST表$logn$复杂度，可以过，于是开始码ST表，发现快11点了，直接rand位置判断是不是$x$就行了。。。</p><p>11点开始看T2：<br>      emmm贪心？？想了一会儿发现LCA性质，直接判断删除LCA即可（一开始傻了想割点）<br>      码完之后发现要凉，搜索可能写跪了，有些地方没有判重。。。<br>      11点40准时收卷，凉了~~  算了，出去吃饭。。</p><p>吃完饭发现210？？（40 + 100 + 70），还有T2直接A掉的神仙操作？？T3为啥只有70？？<br>T1为啥只有40？？玄学<br>看了最终成绩，惊了，Rank1，甩第二30分（浙江选手）。<br>下午董烨华老师来找我，让我去讲课？？有毒？？果断回了一句：我要听NOI讲解~~抱歉啦！</p><p>正解：<br>      首先是出题人首秀（rxd）：难度？？NOI+/ZJOI- WTF。。。</p><pre><code>  题目难度排行：2 1 3/2 3 1，果然T2是最水的。</code></pre><p>—-接下来题解是自己写的：<br>T1：交互维护数据结构，存储n为二进制串，带插入。<br>Add函数：我们需要在开始一次性把所有数加完。<br>考虑加哪些数?结合分治，我们把$l，r分为(l,mid)(mid+1,r)$如果我们把左边的数加入库中，分治时如果我们找到一个数在出现就说明他是在$(l,mid)$范围内，否则$在(mid+1,r)$中，可以完成分治。对于这个操作我们具体讲讲：根据上面所说，我们只对$(l,mid)$进行操作，枚举$i(l&lt;=i&lt;=mid)$我们使$(l,i-1)(i+1,mid)为0，$其他位置都为$1$，把他们都加入库中，这样我们每一层1的个数都不同，所以所有数加入过后不会影响最后分治。<br>$check函数$：我们$对(0,n-1)$进行分治，每次可以判断一个位置上的数在哪个区间，一直递归到底层可得最后答案。</p><p>交互代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &quot;bug.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=333;</span><br><span class="line">int ans[MAXN], vis[MAXN], n;</span><br><span class="line">string s[MAXN];</span><br><span class="line"></span><br><span class="line">inline void insert(int l, int r) &#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    // printf(&quot;Insert %d, %d\n&quot;, l, r);</span><br><span class="line">    string s=&quot;&quot;;</span><br><span class="line">    for(int i=0;i&lt;n;++i) &#123;</span><br><span class="line">        s+=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;l;++i) &#123;</span><br><span class="line">        s[i]=&apos;1&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=r+1;i&lt;n;++i) &#123;</span><br><span class="line">        s[i]=&apos;1&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    for(int i=l;i&lt;=mid;++i) &#123;</span><br><span class="line">        s[i]=&apos;1&apos;;</span><br><span class="line">        // printf(&quot;Add a string : _&quot;);</span><br><span class="line">        // cout&lt;&lt;s;</span><br><span class="line">        // printf(&quot;_\n&quot;);</span><br><span class="line">        add_element(s);</span><br><span class="line">        s[i]=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    insert(l, mid);</span><br><span class="line">    insert(mid+1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int tmp[MAXN];</span><br><span class="line">inline void getans(int l, int r) &#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    string s=&quot;&quot;;</span><br><span class="line">    for(int i=0;i&lt;n;++i) &#123;</span><br><span class="line">        s+=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;l;++i) &#123;</span><br><span class="line">        s[ans[i]]=&apos;1&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=r+1;i&lt;n;++i) &#123;</span><br><span class="line">        s[ans[i]]=&apos;1&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt1=0, cnt2=0, mid=(l+r)&gt;&gt;1;</span><br><span class="line">    for(int i=l;i&lt;=r;++i) &#123;</span><br><span class="line">        int o=ans[i];</span><br><span class="line">        s[o]=&apos;1&apos;;</span><br><span class="line">        // printf(&quot;Check string _&quot;);</span><br><span class="line">        // cout&lt;&lt;s;</span><br><span class="line">        // printf(&quot;_ ; &quot;);</span><br><span class="line">        if(check_element(s)) &#123;</span><br><span class="line">            // puts(&quot;Get True&quot;);</span><br><span class="line">            ++cnt1;</span><br><span class="line">            tmp[l+cnt1-1]=ans[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // puts(&quot;Get False&quot;);</span><br><span class="line">            ++cnt2;</span><br><span class="line">            tmp[mid+cnt2]=ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s[o]=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=l;i&lt;=r;++i) &#123;</span><br><span class="line">        ans[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // for(int i=0;i&lt;n;++i) &#123;</span><br><span class="line">    //     printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">    // &#125;</span><br><span class="line">    // putchar(&apos;\n&apos;);</span><br><span class="line">    getans(l, mid);</span><br><span class="line">    getans(mid+1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; realans;</span><br><span class="line">vector&lt;int&gt; restore_permutation(int nn, int w, int r) &#123;</span><br><span class="line">    n=nn;</span><br><span class="line">    memset(vis, 0, sizeof vis);</span><br><span class="line">    insert(0, n-1);</span><br><span class="line">    compile_set();</span><br><span class="line">    for(int i=0;i&lt;n;++i) &#123;</span><br><span class="line">        ans[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    getans(0, n-1);</span><br><span class="line">    for(int i=0;i&lt;n;++i) &#123;</span><br><span class="line">        tmp[ans[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;++i) &#123;</span><br><span class="line">        realans.push_back(tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return realans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T2:兴奋~考场想出正解<br>直接dp：<br>给定一个实现函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string solve_puzzle(string s, std::vector&lt;int&gt; c) &#123;</span><br><span class="line">int i, j, n = s.length(), m = c.size();</span><br><span class="line">for (i = 0; i &lt; n; i ++) str[i + 1] = s[i];</span><br><span class="line">for (i = 0; i &lt; m; i ++) len[i + 1] = c[i];</span><br><span class="line">for (i = 1; i &lt;= n; i ++) sum[i] = sum[i - 1] + (str[i] == &apos; _ &apos; );</span><br><span class="line">g[n + 1][m + 1] = true;</span><br><span class="line">for (i = n; i &gt;= 0; i --) if (str[i] != &apos;X&apos;) for (j = m + 1; j &gt;= 1; j --)</span><br><span class="line">g[i][j] = g[i + 1][j] || (j &lt;= m &amp;&amp; i + len[j] &lt;= n &amp;&amp; g[i + len[j] + 1][j + 1] &amp;&amp; sum[i + len[j]] == sum[i]);</span><br><span class="line">f[0][0] = true;</span><br><span class="line">for (i = 1; i &lt;= n + 1; i ++) if (str[i] != &apos;X&apos;) for (j = 0; j &lt;= m; j ++) if (g[i][j + 1]) &#123;</span><br><span class="line">if (f[i - 1][j]) mark[i] = f[i][j] = true;</span><br><span class="line">if (j &gt; 0 &amp;&amp; i &gt; len[j] &amp;&amp; sum[i - 1] == sum[i - len[j] - 1] &amp;&amp; f[i - len[j] - 1][j - 1])</span><br><span class="line">mark[i] = f[i][j] = true, cnt[i - len[j]] ++, cnt[i] --;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 1; i &lt;= n; i ++) cnt[i] += cnt[i - 1];</span><br><span class="line">string ret (n, &apos;?&apos;);</span><br><span class="line">for (i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">if (!cnt[i + 1]) ret[i] = &apos; _ &apos;;</span><br><span class="line">if (!mark[i + 1]) ret[i] = &apos;X&apos;;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T3：玄学题以及幻想的最简单题：<br>处理以每个修改点左长k和右长k区间，丢入权值线段树（出题人）</p><p>主席树存数据，线段树存询问（某ACer大佬）</p><p>行吧，自己又码了一遍，恶心自己。。。</p><p>看NOIP讲解：<br>T1 $设f[i] 表示i之后有多少个和x不同的，sb题不说了$。</p><p>T2：居然写出了正解！！？？ 无聊的LCA。</p><p>T3：完全正解，树状数组离线，也可以可持久化线段树，可能会T？？<br>    为啥错？没开long long？？？我去。。。</p><p>说暴力分：100 + 30 + 50</p><p>我的分： 40 + 100 + 70  （手动滑稽）</p><p>晚上受到了宿舍其他两个人各种\%，直接鞠躬大佬了，在这里在此声明：考好是运气，考差是实力~</p><p>回顾一下，其实也是可以AK的，各种无聊的错误。。。</p><p>晚上回去都有点莫名的伤感，只是没有表达出来罢了。<br>明天就分道扬镳了，晚上直接熬夜搭blog，搭到凌晨4点发现还是不行，直接睡了，闭眼就着（困死）</p><h2 id="Day7："><a href="#Day7：" class="headerlink" title="Day7："></a>Day7：</h2><p>滚粗日</p><p>一大早发现答应好的饭没有了，差评~~。<br>而且困的要死，还不如不睡。</p><p>赶到火车站陪着小朋友等他的教练，然后几乎没有时间吃饭了。。。<br>之后就是全程火车陪护以及睡觉。。</p><p>下午4点，踏上石家庄的土地，特别想高喊：我yyh又回来了！！！</p><p>然后开始考虑落下了一周的课，要凉~~~</p><p>总结：<br>    去了一趟收获颇多，看到了自己与别人的差距以及自己的优势（？？？可能没有），觉得自己要更好好学了，它的模拟赛实际上不是特别难？？但是感觉一种说不出来的不好感。。。加油，自己！！</p>]]></content>
    
    <summary type="html">
    
      处世
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="训练报告" scheme="http://yoursite.com/tags/%E8%AE%AD%E7%BB%83%E6%8A%A5%E5%91%8A/"/>
    
      <category term="私密" scheme="http://yoursite.com/tags/%E7%A7%81%E5%AF%86/"/>
    
  </entry>
  
</feed>
